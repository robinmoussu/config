enum touche {
    c_ALT,
    c_CTRL,
    c_a,
    c_A,
    c_b,
    c_B
};

using Code_char = char;
void usb_send(Code_char c); /// send hexadecimal code touche via usb

/// convert the name of the caractere to his value in azerty/qwerty/whatever
enum Codemap {
    QWERTY,
    AZERTY,
    BEPO
};
void put_char(char c)
{
    Codemap lang = QWERTY;

    switch (lang) {
        case QWERTY:
            switch (c) {
                case c_a:
                    usb_send(0x0a);
                    break;
                case c_b:
                    usb_send(0x0b);
                    break;
                case c_A:
                    usb_send(0x1a);
                    break;
                case c_B:
                    usb_send(0x1b);
                    break;
                case c_ALT:
                    usb_send(0xc);
                    break;
                case c_CTRL:
                    usb_send(0xd);
                    break;
                default:
                    //static_assert (0==1, "caractere invalide");
                    break;
            }
            break;
        case AZERTY:
            switch (c) {
                case c_a:
                    usb_send(0x0a);
                    break;
                case c_b:
                    usb_send(0x0b);
                    break;
                case c_A:
                    usb_send(0x1a);
                    break;
                case c_B:
                    usb_send(0x1b);
                    break;
                case c_ALT:
                    usb_send(0xc);
                    break;
                case c_CTRL:
                    usb_send(0xd);
                    break;
                default:
                    //static_assert (0==1, "caractere invalide");
                    break;
            }
            break;
    }
}

enum ROW {
    k_FONCTION,
    k_UP,
    k_MIDDLE,
    k_DOWN,
    NB_ROW
};
enum FONCTION_KEY {
    k_ALT,
    k_CTRL
}

enum MOD_KEY {
    m_ALT,
    m_CTRL
}
constexpr int NB_MAX_MODIFIERS;
class Modifiers {
    public:
        void latch(MOD_KEY m);
        void send(MOD_KEY m);
        void lock(MOD_KEY m);
        void unlock(MOD_KEY m);

    protected:
        static_array<bool,NB_MAX_MODIFIERS> m_state;
};
void (*f) (Modifiers m);
void f_alt(Modifiers m) {
    m.latch(m_ALT);
}
void f_ctrl(Modifiers m) {
    m.latch(m_CTRL);
}
void f_a(Modifiers m) {
    if 
    put_char(c_a);
}
void f_b(Modifiers m) {
    put_char(c_b);
}
void f_macro(Modifiers m) {
    // send ctrl + a
    m.setMod(k_CTRL);
    put_char(c_a);
}
using F_key = static_array<vector<f>, NB_ROW>;
F_key function_key = {
    { // k_FONCTION
        f_alt, f_ctrl
    },
    { // k_UP
        f_b
    },
    { // k_MIDDLE
        f_a
    },
    { // k_DOWN
        f_macro
    },
};

struct Code_touche {
    int row,column;
}
void input(Code_touche c)
{
    Modifiers m;
    function_key[c.row][c.column] (m);
}




